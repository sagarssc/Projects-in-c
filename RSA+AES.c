#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<math.h>

int public_key_e(int ,int ,int);
int SBox(int num);
void KeyExpansion();
int hex(char);
int private_key_d(int ,int);
int cipher_text(int e,int n,char* msg); //Encryption
void decSubBytes();
int plain_text(int *ct,int n,int d,int r); //Decryption
void AddRoundKey(int );
void MixColumns();
void decMixColumns();
void SubBytes();
void ShiftRows();
void encrypt();
void decrypt();
int SBoxdec(int );
void decShiftRows();

#define Nb 4
#define mix(x)   ((x<<1) ^ (((x>>7) & 1) * 0x1b))
#define Mul(x,y) (((y & 1) * x) ^ ((y>>1 & 1) * mix(x)) ^ ((y>>2 & 1) * mix(mix(x))) ^ ((y>>3 & 1) * mix(mix(mix(x)))) ^ ((y>>4 & 1) * mix(mix(mix(mix(x))))))

int Nr=0;
int Nk=0;
unsigned char input[16], output[16], st[4][4],RKey[240],Key[32];

int main(){
int pl,n,p,q,z,r,phi,e,d,i=0;
int ct[20];
char msg[100],ch;
int l,o,a; 
char txt[16],k[16];

printf("--------------------------Encryption/Decryption----------------------------\n\n\n\n");
printf("---------------------Choose Encryption/Decryption Method-------------------\n\n");
printf("	1:-AES Algorithm - Encryption\n");
printf("	2:-AES Algorithm - Decryption\n");
printf("	3:-RSA Algorithm - Key Geration\n");
printf("	4:-RSA Algorithm - Encryption\n");
printf("	5:-RSA Algorithm - Decryption\n");
printf("	====>");
scanf("%d",&o);
switch(o){
case 1: printf("------------------------------AES Algorithm(128)-----------------------------------\n");

        unsigned char temp[16],temp2[16];
 
                Nr=128;
                printf("Enter the Text : ");
                scanf("%s",txt);
                for(i=0;i<strlen(txt);i++){
                 temp2[i]=hex(txt[i]);  
                 }
                printf("Enter the Key : ");
                scanf("%s",k);
                 for(i=0;i<strlen(k);i++){
                 temp[i]=hex(k[i]);  
                 } 
                Nk = Nr / 32;
                Nr = Nk + 6;
                for(i=0;i<Nk*4;i++){
                Key[i]=temp[i];
        
                input[i]=temp2[i];}
               KeyExpansion();
               encrypt();
               printf("\nText after encryption:\n");
              for(i=0;i<Nk*4;i++){
              printf("%02x ",output[i]); 

             }
             printf("\n\n");break;

case 2:                Nr=128;
                printf("Enter the text in hexadecimal: ");
      
               Nk = Nr / 32;
               Nr = Nk + 6; 
              for(i=0;i<Nk*4;i++)
                 {
             fflush(stdin);  
              scanf("%X",&temp2[i]);}
     
                printf("Enter the Key : ");
               fflush(stdin);
                  scanf("%s",k);
                 for(i=0;i<strlen(k);i++){
                 temp[i]=hex(k[i]);  
                 } 
           for(i=0;i<Nk*4;i++){
               Key[i]=temp[i];
               input[i]=temp2[i];}
               KeyExpansion();
               decrypt();
        char out1[2];
               printf("\nText after decryption:\n");
              for(i=0;i<Nb*4;i++)      {
              //printf("%02x ",out[i]);
        sprintf(out1, "%x", output[i]);
    
        int l,a[1][8],k=0,j=0;
        for(l=0;l<2;l++){
        if(out1[l]=='0'){
        a[j][k]=0;k++;
        a[j][k]=0;k++;
        a[j][k]=0;k++;
        a[j][k]=0;k++;
        }
        if(out1[l]=='1'){
        a[j][k]=0;k++;
        a[j][k]=0;k++;
        a[j][k]=0;k++;
        a[j][k]=1;k++;
        }
        if(out1[l]=='2'){
        a[j][k]=0;k++;
        a[j][k]=0;k++;
        a[j][k]=1;k++;        
        a[j][k]=0;k++;
        }
        if(out1[l]=='3'){
        a[j][k]=0;k++;
        a[j][k]=0;k++;
        a[j][k]=1;k++;
        a[j][k]=1;k++;
        }
        if(out1[l]=='4'){
        a[j][k]=0;k++;
        a[j][k]=1;k++;
        a[j][k]=0;k++;
        a[j][k]=0;k++;
        }
        if(out1[l]=='5'){
        a[j][k]=0;k++;
        a[j][k]=1;k++;
        a[j][k]=0;k++;
        a[j][k]=1;k++;
        }
        if(out1[l]=='6'){
        a[j][k]=0;k++;
        a[j][k]=1;k++;
        a[j][k]=1;k++;
        a[j][k]=0;k++;
        }
        if(out1[l]=='7'){
        a[j][k]=0;k++;
        a[j][k]=1;k++;
        a[j][k]=1;k++;
        a[j][k]=1;k++;
        }
        if(out1[l]=='8'){
        a[j][k]=1;k++;
        a[j][k]=0;k++;
        a[j][k]=0;k++;
        a[j][k]=0;k++;
        }
        if(out1[l]=='9'){
        a[j][k]=1;k++;
        a[j][k]=0;k++;
        a[j][k]=0;k++;
        a[j][k]=1;k++;
        }
        if(out1[l]=='a'){
        a[j][k]=1;k++;
        a[j][k]=0;k++;
        a[j][k]=1;k++;
        a[j][k]=0;k++;
        }
        if(out1[l]=='b'){
        a[j][k]=1;k++;
        a[j][k]=0;k++;
        a[j][k]=1;k++;
        a[j][k]=1;k++;
        }
        if(out1[l]=='c'){
        a[j][k]=1;k++;
        a[j][k]=1;k++;
        a[j][k]=0;k++;
        a[j][k]=0;k++;
        }
        if(out1[l]=='d'){
        a[j][k]=1;k++;
        a[j][k]=1;k++;
        a[j][k]=0;k++;
        a[j][k]=1;k++;
        }
        if(out1[l]=='e'){
        a[j][k]=1;k++;
        a[j][k]=1;k++;
        a[j][k]=1;k++;
        a[j][k]=0;k++;
        }
        if(out1[l]=='f'){
        a[j][k]=1;k++;
        a[j][k]=1;k++;
        a[j][k]=1;k++;
        a[j][k]=1;k++;
        }
        }
        int q=0;
        for(j=7;j>=0;j--){
        q=q+(a[0][j]*pow(2,7-j));
        }
         //printf("%d	",q);
        if(q>=65 && q<=90 || q>=97 && q<=123 ){
        printf("%c",q);}
        }
              printf("\n\n");break;
       

case 3: printf("	Enter Two prime No.\n	   ==>");
                scanf("%d %d",&p,&q);
                n=p*q;                 /*  Public key n */
                phi=(p-1)*(q-1);
                e=public_key_e(phi,p,q);
                d=private_key_d(phi,e);
                printf("	Public Key n = %d  and  e = %d\n",n,e);
                printf("	Private Key d = %d\n",d);
                break;
case 4: printf("	Please Enter the Message:\n	    ==>");
                scanf("%s",msg);
                printf("	Enter the value of public key e:\n	 ==>");
                scanf("%d",&e);
                printf("	Enter the value of public key n:\n	==>");
                scanf("%d",&n);
                cipher_text(e,n,msg);
                break;
case 5: printf("	Please Enter the no. of cipher text blocks:\n	  ==>");
                scanf("%d",&r);
                for(i=0;i<r;i++){
                printf("Cipher Text %d:",i+1);
                scanf("%d",&ct[i]);
                }
                printf("	Enter the of public key n:\n	==>");
                scanf("%d",&n);
                printf("	Enter the value of private key d:\n	==>");
                scanf("%d",&d);
                plain_text(ct,n,d,r);main();
                break;
default: printf("	Please Enter the valid No.\n");        
        }
}
int hex(char a){
int i;
i=a;
int ar[256] =
        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 
          0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
          0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
          0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 
          0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 
          0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
          0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
          0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
          0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
          0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
          0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
          0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
          0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
          0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,
          0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
          0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff };
return ar[i];
}

void decSubBytes(){
int i,j;
for(i=0;i<4;i++)
{for(j=0;j<4;j++){
st[i][j] = SBoxdec(st[i][j]);
}}}

void decShiftRows(){
unsigned char temp;
temp=st[1][3];
st[1][3]=st[1][2];
st[1][2]=st[1][1];
st[1][1]=st[1][0];
st[1][0]=temp;
temp=st[2][0];
st[2][0]=st[2][2];
st[2][2]=temp;
temp=st[2][1];
st[2][1]=st[2][3];
st[2][3]=temp;
temp=st[3][0];
st[3][0]=st[3][1];
st[3][1]=st[3][2];
st[3][2]=st[3][3];
st[3][3]=temp;
}

/* Public Key e Generation*/
int public_key_e(int r,int p,int q){ //r=phi
int s=2,t=0,z,a,i;
while(r!=1){
  if(r%s==0){
    r=r/s; 
     a=s;
        }
  else{
    s++;
      }
}
while(t!=1){
   a++;z=0;
 for(i=1;i<=a;i++){  
  if(a%i==0){z++;}
   }
if(a!=p && a!=q && z==2){
   t=1;
   return a;
   }
  
  }
/*end of function*/
}

/* Private Key Generation*/
int private_key_d(int phi,int e){
int a,b,c=e,d,j,k,l,m,temp1,temp2,temp3,i=0;

while(c!=1){
  if(i==0){
    j=1;k=0;
    l=phi;
     d=0;
    }
  else if(i==1){
    a=0;b=1;
    c=e;
    d=l/c;
    }
  else if(i>1){
   temp1=a;  /*Storing in a temp variable*/
   temp2=b;
   temp3=c;

   a=j-a*d;  /*an=a(n-2)-d*a(n-1);*/
   b=k-b*d;  /*bn=a(n-2)-d*c(n-1);*/
   c=l-c*d;  /*cn=a(n-2)-d*c(n-1);*/

   j=temp1;
   k=temp2;
   l=temp3;
   d=l/c;
   }
i++;
}
if(b<0){
return (b+phi);
}
else if(b>phi){
return (b%phi);
}
else{
return b;
}
/*end of function*/
}

/*#define mix(x)   ((x<<1) ^ (((x>>7) & 1) * 0x1b))*/
void MixColumns(){
int i;
unsigned char T1,T2,t;
for(i=0;i<4;i++){
t=st[0][i];
T1 = st[0][i] ^ st[1][i] ^ st[2][i] ^ st[3][i] ;
T2 = st[0][i] ^ st[1][i] ; 
T2 = mix(T2); 
st[0][i] ^= T2 ^ T1 ;
T2 = st[1][i] ^ st[2][i] ; 
T2 = mix(T2); 
st[1][i] ^= T2 ^ T1 ;
T2 = st[2][i] ^ st[3][i] ; 
T2 = mix(T2); 
st[2][i] ^= T2 ^ T1 ;
T2 = st[3][i] ^ t ; 
T2 = mix(T2); 
st[3][i] ^= T2 ^ T1 ;
}}



void decrypt()
{
int i,j,round=0;
for(i=0;i<4;i++)
{for(j=0;j<4;j++){
st[j][i] = input[i*4 + j];
}}
AddRoundKey(Nr);
for(round=Nr-1;round>0;round--){
decShiftRows();
decSubBytes();
AddRoundKey(round);
decMixColumns();}
decShiftRows();
decSubBytes();
AddRoundKey(0);
for(i=0;i<4;i++)
{for(j=0;j<4;j++){
output[i*4+j]=st[j][i];
}}}


void decMixColumns(){
int i;
unsigned char a,b,c,d;
for(i=0;i<4;i++){
a = st[0][i];b = st[1][i];c = st[2][i];d = st[3][i];
st[0][i] = Mul(a, 0x0e) ^ Mul(b, 0x0b) ^ Mul(c, 0x0d) ^ Mul(d, 0x09);st[1][i] = Mul(a, 0x09) ^ Mul(b, 0x0e) ^ Mul(c, 0x0b) ^ Mul(d, 0x0d);st[2][i] = Mul(a, 0x0d) ^ Mul(b, 0x09) ^ Mul(c, 0x0e) ^ Mul(d, 0x0b);st[3][i] = Mul(a, 0x0b) ^ Mul(b, 0x0d) ^ Mul(c, 0x09) ^ Mul(d, 0x0e);
}}


int cipher_text(int e,int n,char* b){
int cr,m,i,k,l,c,q,p=0,*ar=NULL,pt,w,alen,index;
char ch[20],s[20],str[200],str1[4];
l=strlen(b);
int j[l];
printf("--------Cipher Text-------\n");
for(i=0;i<l;i++){
c=1;*s=NULL;*ch=NULL;
                                /*generating numeric value of text*/
j[i]=b[i];
if(j[i]>=65 && j[i]<=90){
j[i]=j[i]-64;
}
if(j[i]==32){
j[i]=53;
}
if(j[i]>=97 && j[i]<=123){
j[i]=j[i]-70;
} 
                                  /*Encryption*/
for(k=0;k<e;k++){
c=(c*j[i])%n;
}
                           /*conversion int to string and adding 0 before the no. if <10 */
sprintf(ch,"%d",c);
sprintf(s,"%d",p);
if(c<10){
strcat(s,ch);
strcat(str,s);
}
else{
strcat(str,ch);
}}
                       /*Deviding  String into small blocks of size 4*/
k=strlen(str);
m=k;
if(k%4!=0){
k=k/4+1;
}
else{
k=k/4;
}
for(i=0;i<k;i++){
for(q=0;q<4;q++){
str1[q]=str[q+(4*i)];
}        
                   /*conversion string to int and storing in array*/
if( ar == NULL )
     {
       ar = malloc(sizeof(atoi(str1)));
       *ar =atoi(str1);
     }
    else
    { 
       ar = realloc(ar,sizeof(ar)*i);  
        index = i;
       *(ar+index)=atoi(str1);
   }
printf("Cipher Text %d = %d\n",i+1,ar[i]);    
alen=i+1;
}
           /*end of function*/
}




void encrypt(){
int i,j,round=0;
for(i=0;i<4;i++)
{for(j=0;j<4;j++)   { st[j][i] = input[i*4 + j];}}
AddRoundKey(0);
for(round=1;round<Nr;round++){
SubBytes();ShiftRows();MixColumns();AddRoundKey(round);}
SubBytes();ShiftRows();AddRoundKey(Nr);
for(i=0;i<4;i++){
for(j=0;j<4;j++){
output[i*4+j]=st[j][i];}}
}

int plain_text(int *c,int n,int d,int r){
int k,m,i,a,pl,j=0;
char ch,temp[100];
for(k=r-1;k>=0;k--){
while(c[k]>0){
a=c[k]%100; //temp variable block
pl=1;
for(i=0;i<d;i++){
pl=(a*pl)%n;    //formula
}
if(pl>=1 && pl<=26){
pl=pl+64;
}
if(pl==53){
pl=32;
}
if(pl>=27 && pl<=52){
pl=pl+70;
}
temp[j]=pl;
j++;
c[k]=c[k]/100;
}}
printf("\nTest Message:\n==> ");
for(m=j;m>0;m--){
printf("%c",temp[m-1]);
}
printf("\n");
/*end of function*/
}

void AddRoundKey(int round)
{
    int i,j;
    for(i=0;i<4;i++)
    {for(j=0;j<4;j++){st[j][i] ^= RKey[round * 4 * 4 + i * 4 + j];   }}
}
void SubBytes()
{
    int i,j;
    for(i=0;i<4;i++){
        for(j=0;j<4;j++){ st[i][j] = SBox(st[i][j]);}}
}

int SBox(int num)
{
    int sbox[256] =   {
0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 };    
 return sbox[num];}

int Rcon[255] = {
0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a,
0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc,
0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94,
0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f,
0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd,
0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb  };


void KeyExpansion()
{
int i,j;
unsigned char temp[4],k;
for(i=0;i<Nk;i++)
{
RKey[i*4]=Key[i*4];RKey[i*4+1]=Key[i*4+1];RKey[i*4+2]=Key[i*4+2];RKey[i*4+3]=Key[i*4+3];
}
while (i < (4 * (Nr+1)))
{for(j=0;j<4;j++)
{temp[j]=RKey[(i-1) * 4 + j];}
if (i % Nk == 0)
{
{
k = temp[0];
temp[0] = temp[1];
temp[1] = temp[2];
temp[2] = temp[3];
temp[3] = k;
}
{
temp[0]=SBox(temp[0]);
temp[1]=SBox(temp[1]);
temp[2]=SBox(temp[2]);
temp[3]=SBox(temp[3]);
}temp[0] =  temp[0] ^ Rcon[i/Nk];
}
else if (Nk > 6 && i % Nk == 4)
{{temp[0]=SBox(temp[0]);temp[1]=SBox(temp[1]);temp[2]=SBox(temp[2]);temp[3]=SBox(temp[3]); }}
RKey[i*4+0] = RKey[(i-Nk)*4+0] ^ temp[0];
RKey[i*4+1] = RKey[(i-Nk)*4+1] ^ temp[1];
RKey[i*4+2] = RKey[(i-Nk)*4+2] ^ temp[2];
RKey[i*4+3] = RKey[(i-Nk)*4+3] ^ temp[3];i++;}
}
void ShiftRows()
{    unsigned char temp;
temp=st[1][0];
st[1][0]=st[1][1];
st[1][1]=st[1][2];
st[1][2]=st[1][3];
st[1][3]=temp;
temp=st[2][0];
st[2][0]=st[2][2];
st[2][2]=temp;
temp=st[2][1];
st[2][1]=st[2][3];
st[2][3]=temp;
temp=st[3][0];
st[3][0]=st[3][3];
st[3][3]=st[3][2];
st[3][2]=st[3][1];
st[3][1]=temp;
}


/*
void gmix_column(unsigned char *r) {
    unsigned char a[4];
    unsigned char b[4];
    unsigned char c;
    unsigned char h;
    //* The array 'a' is simply a copy of the input array 'r'
     * The array 'b' is each element of the array 'a' multiplied by 2
     * in Rijndael's Galois field
     * a[n] ^ b[n] is element n multiplied by 3 in Rijndael's Galois field /*
    for (c = 0; c < 4; c++) {
        a[c] = r[c];
        /* h is 0xff if the high bit of r[c] is set, 0 otherwise *
        h = (unsigned char)((signed char)r[c] >> 7); /* arithmetic right shift, thus shifting in either zeros or ones *
        b[c] = r[c] << 1; /* implicitly removes high bit because b[c] is an 8-bit char, so we xor by 0x1b and not 0x11b in the next line *
        b[c] ^= 0x1B & h; /* Rijndael's Galois field *
    }
    r[0] = b[0] ^ a[3] ^ a[2] ^ b[1] ^ a[1]; /* 2 * a0 + a3 + a2 + 3 * a1 *
    r[1] = b[1] ^ a[0] ^ a[3] ^ b[2] ^ a[2]; /* 2 * a1 + a0 + a3 + 3 * a2 *
    r[2] = b[2] ^ a[1] ^ a[0] ^ b[3] ^ a[3]; /* 2 * a2 + a1 + a0 + 3 * a3 *
    r[3] = b[3] ^ a[2] ^ a[1] ^ b[0] ^ a[0]; /* 2 * a3 + a2 + a1 + 3 * a0 *
}*/
int SBoxdec(int num){
int rsbox[256] ={ 0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d };
return rsbox[num];
}








